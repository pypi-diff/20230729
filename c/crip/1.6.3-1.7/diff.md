# Comparing `tmp/crip-1.6.3-py3-none-any.whl.zip` & `tmp/crip-1.7-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,19 +1,20 @@
-Zip file size: 4728299 bytes, number of entries: 111
--rw-rw-rw-  2.0 fat      666 b- defN 23-Mar-21 05:27 crip/__init__.py
+Zip file size: 4730925 bytes, number of entries: 112
+-rw-rw-rw-  2.0 fat      662 b- defN 23-Jul-29 06:25 crip/__init__.py
 -rw-rw-rw-  2.0 fat      766 b- defN 23-Mar-21 05:27 crip/_typing.py
--rw-rw-rw-  2.0 fat     4206 b- defN 23-Mar-21 05:42 crip/de.py
--rw-rw-rw-  2.0 fat     8354 b- defN 23-Apr-30 23:30 crip/io.py
+-rw-rw-rw-  2.0 fat     5698 b- defN 23-Jul-07 17:14 crip/de.py
+-rw-rw-rw-  2.0 fat    10520 b- defN 23-Jul-29 06:25 crip/io.py
 -rw-rw-rw-  2.0 fat     2614 b- defN 23-May-18 15:00 crip/lowdose.py
 -rw-rw-rw-  2.0 fat    11032 b- defN 23-Jun-01 12:42 crip/mangoct.py
 -rw-rw-rw-  2.0 fat     1431 b- defN 23-Mar-21 05:41 crip/metric.py
 -rw-rw-rw-  2.0 fat     2702 b- defN 23-May-18 15:00 crip/paplot.py
--rw-rw-rw-  2.0 fat    13593 b- defN 23-May-18 15:00 crip/physics.py
+-rw-rw-rw-  2.0 fat    14180 b- defN 23-Jul-29 06:26 crip/physics.py
+-rw-rw-rw-  2.0 fat     2702 b- defN 23-Jul-29 06:25 crip/plot.py
 -rw-rw-rw-  2.0 fat     3724 b- defN 23-May-18 15:00 crip/postprocess.py
--rw-rw-rw-  2.0 fat     8211 b- defN 23-May-18 17:19 crip/preprocess.py
+-rw-rw-rw-  2.0 fat     8217 b- defN 23-Jul-07 17:14 crip/preprocess.py
 -rw-rw-rw-  2.0 fat     6678 b- defN 23-Mar-21 05:27 crip/shared.py
 -rw-rw-rw-  2.0 fat     5528 b- defN 23-May-03 08:10 crip/utils.py
 -rw-rw-rw-  2.0 fat        0 b- defN 23-Mar-21 05:27 crip/_atten/__init__.py
 -rw-rw-rw-  2.0 fat     1304 b- defN 23-Mar-21 05:27 crip/_atten/_attenList.json
 -rw-rw-rw-  2.0 fat      548 b- defN 23-May-01 01:06 crip/_atten/_classicRho.json
 -rw-rw-rw-  2.0 fat      627 b- defN 23-Mar-21 05:27 crip/_atten/_updateList.py
 -rw-rw-rw-  2.0 fat      592 b- defN 23-Mar-21 05:27 crip/_atten/compound/CaF2.txt
@@ -101,13 +102,13 @@
 -rw-rw-rw-  2.0 fat      922 b- defN 23-Mar-21 05:27 crip/_atten/simple/Ni.txt
 -rw-rw-rw-  2.0 fat      823 b- defN 23-Mar-21 05:27 crip/_atten/simple/O.txt
 -rw-rw-rw-  2.0 fat      691 b- defN 23-Mar-21 05:27 crip/_atten/simple/P.txt
 -rw-rw-rw-  2.0 fat      691 b- defN 23-Mar-21 05:27 crip/_atten/simple/S.txt
 -rw-rw-rw-  2.0 fat      823 b- defN 23-Mar-21 05:27 crip/_atten/simple/Si.txt
 -rw-rw-rw-  2.0 fat      526 b- defN 23-Mar-21 05:27 crip/_atten/simple/Sn.txt
 -rw-rw-rw-  2.0 fat   652928 b- defN 23-Mar-21 05:27 crip/_atten/simple/Ti_ICRP.txt
--rw-rw-rw-  2.0 fat     1052 b- defN 23-Jun-01 12:43 crip-1.6.3.dist-info/LICENSE
--rw-rw-rw-  2.0 fat      526 b- defN 23-Jun-01 12:43 crip-1.6.3.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 23-Jun-01 12:43 crip-1.6.3.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        5 b- defN 23-Jun-01 12:42 crip-1.6.3.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     9154 b- defN 23-Jun-01 12:43 crip-1.6.3.dist-info/RECORD
-111 files, 12759420 bytes uncompressed, 4714019 bytes compressed:  63.1%
+-rw-rw-rw-  2.0 fat     1052 b- defN 23-Jul-29 06:27 crip-1.7.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat      524 b- defN 23-Jul-29 06:27 crip-1.7.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Jul-29 06:27 crip-1.7.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        5 b- defN 23-Jul-29 06:27 crip-1.7.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     9214 b- defN 23-Jul-29 06:27 crip-1.7.dist-info/RECORD
+112 files, 12766427 bytes uncompressed, 4716565 bytes compressed:  63.1%
```

## zipnote {}

```diff
@@ -21,14 +21,17 @@
 
 Filename: crip/paplot.py
 Comment: 
 
 Filename: crip/physics.py
 Comment: 
 
+Filename: crip/plot.py
+Comment: 
+
 Filename: crip/postprocess.py
 Comment: 
 
 Filename: crip/preprocess.py
 Comment: 
 
 Filename: crip/shared.py
@@ -312,23 +315,23 @@
 
 Filename: crip/_atten/simple/Sn.txt
 Comment: 
 
 Filename: crip/_atten/simple/Ti_ICRP.txt
 Comment: 
 
-Filename: crip-1.6.3.dist-info/LICENSE
+Filename: crip-1.7.dist-info/LICENSE
 Comment: 
 
-Filename: crip-1.6.3.dist-info/METADATA
+Filename: crip-1.7.dist-info/METADATA
 Comment: 
 
-Filename: crip-1.6.3.dist-info/WHEEL
+Filename: crip-1.7.dist-info/WHEEL
 Comment: 
 
-Filename: crip-1.6.3.dist-info/top_level.txt
+Filename: crip-1.7.dist-info/top_level.txt
 Comment: 
 
-Filename: crip-1.6.3.dist-info/RECORD
+Filename: crip-1.7.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## crip/__init__.py

```diff
@@ -2,20 +2,20 @@
 __author__ = 'z0gSh1u'
 __license__ = 'MIT License'
 __doc__ = '''
 An all-in-one tool for Cone-Beam CT Data IO, Pre/Post-process, and Physics, Dual Energy, Low Dose, Deep Learning researches and everything only except Reconstruction.
 https://github.com/z0gSh1u/crip
 '''
 
-__all__ = ['de', 'io', 'lowdose', 'physics', 'postprocess', 'preprocess', 'shared', 'utils', 'mangoct', 'paplot', 'metric']
+__all__ = ['de', 'io', 'lowdose', 'physics', 'postprocess', 'preprocess', 'shared', 'utils', 'mangoct', 'plot', 'metric']
 
 from . import de
 from . import io
 from . import lowdose
 from . import physics
 from . import postprocess
 from . import preprocess
 from . import shared
 from . import utils
 from . import mangoct
-from . import paplot
+from . import plot
 from . import metric
```

## crip/de.py

```diff
@@ -1,17 +1,22 @@
 '''
     Dual-Energy CT module of crip.
 
     https://github.com/z0gSh1u/crip
 '''
 
-__all__ = ['singleMatMuDecomp', 'calcAttenedSpec', 'calcPostLog', 'deDecompGetCoeff', 'deDecompProj', 'deDecompRecon']
+__all__ = [
+    'singleMatMuDecomp', 'calcAttenedSpec', 'calcPostLog', 'deDecompGetCoeff', 'deDecompProj', 'deDecompRecon',
+    'genMaterialPhantom'
+]
 
 import numpy as np
+from scipy.ndimage import uniform_filter
 
+from .postprocess import gaussianSmooth
 from .utils import ConvertListNDArray, cripAssert, cripWarning, is2D, isOfSameShape
 from ._typing import *
 from .physics import Atten, DiagEnergyRange, Spectrum, calcAttenedSpec, calcPostLog
 
 
 def singleMatMuDecomp(src: Atten, base1: Atten, base2: Atten, method='coeff', energyRange=DiagEnergyRange) -> NDArray:
     '''
@@ -83,31 +88,75 @@
     def applyPolyV2L2(coeff, A1, A2):
         return coeff[0] * A1**2 + coeff[1] * A2**2 + coeff[2] * A1 * A2 + coeff[3] * A1 + coeff[4] * A2 + coeff[5]
 
     return applyPolyV2L2(coeff1, lowProj, highProj), applyPolyV2L2(coeff2, lowProj, highProj)
 
 
 @ConvertListNDArray
-def deDecompRecon(low: TwoOrThreeD, high: TwoOrThreeD, muBase1Low: float, muBase1High: float, muBase2Low: float,
-                  muBase2High: float, checkCond: bool = True):
+def deDecompRecon(low: TwoOrThreeD,
+                  high: TwoOrThreeD,
+                  muBase1Low: float,
+                  muBase1High: float,
+                  muBase2Low: float,
+                  muBase2High: float,
+                  checkCond: bool = True):
     '''
         Perform dual-energy decompose in reconstruction domain. \\mu values can be calculated using @see `calcMu`.
 
         The values of input volumes should be \\mu value. The outputs are decomposing coefficients.
     '''
     cripAssert(isOfSameShape(low, high), 'Two volumes should have same shape.')
     COND_TOLERANCE = 1000
 
     A = np.array([[muBase1Low, muBase2Low], [muBase1High, muBase2High]])
     if checkCond:
-        cripWarning(np.linalg.cond(A) <= COND_TOLERANCE, 'The material decomposition matrix possesses high condition number.')
+        cripWarning(
+            np.linalg.cond(A) <= COND_TOLERANCE, 'The material decomposition matrix possesses high condition number.')
     M = np.linalg.inv(A)
 
     def decompOne(low, high):
         c1 = M[0, 0] * low + M[0, 1] * high
         c2 = M[1, 0] * low + M[1, 1] * high
         return c1, c2
 
     if is2D(low):
         return decompOne(low, high)
     else:
         return np.array(list(map(lambda args: decompOne(*args), zip(low, high)))).transpose((1, 0, 2, 3))
+
+
+def softThreshold(img: np.ndarray, l, h, mode='lower'):
+    shape = img.shape
+    img = img.flatten()
+
+    lower = img < l
+    upper = img >= h
+
+    transitional = (img >= l) * (img < h)
+    if mode == 'upper':
+        transitional = transitional * (img - l) / (h - l)
+        res = upper + transitional
+    elif mode == 'lower':
+        transitional = transitional * (h - img) / (h - l)
+        res = lower + transitional
+
+    return res.reshape(shape)
+
+
+def genMaterialPhantom(img, zsmooth=3, sigma=1, l=80, h=300, base=1000):
+    '''
+        Generate the phantom of material bases (one is water) from SECT using soft-thresholding.
+        zsmooth: smooth window in slice direction.
+        sigma: Gaussian smooth sigma in single slice.
+        [l, h] defines the fuzzy range of another material, e.g., bone.
+        base: the reference HU of another material.
+    '''
+    assert np.min(img) < 0  # HU
+
+    kernel = (zsmooth, 1, 1) if zsmooth is not None else (1, 1)
+    img = uniform_filter(img, kernel, mode='reflect')
+    img = gaussianSmooth(img, sigma)
+
+    water = (img + 1000) / 1000 * softThreshold(img, l, h, 'lower')
+    b2 = (img + 1000) / (base + 1000) * softThreshold(img, l, h, 'upper')
+
+    return water, b2
```

## crip/io.py

```diff
@@ -2,15 +2,15 @@
     I/O module of crip.
 
     https://github.com/z0gSh1u/crip
 '''
 
 __all__ = [
     'listDirectory', 'imreadDicom', 'readDicom', 'imreadRaw', 'imwriteRaw', 'imreadTiff', 'imwriteTiff', 'CTPARAMS',
-    'fetchCTParam'
+    'fetchCTParam', 'readEVI', 'imreadEVI'
 ]
 
 import os
 import numpy as np
 import tifffile
 import pydicom
 import natsort
@@ -178,14 +178,76 @@
         img = img.astype(dtype)
     if isFloatDtype(img.dtype):
         img = img.astype(np.float32)  # always use float32 for floating image.
 
     tifffile.imwrite(path, img)
 
 
+def readEVI(path: str):
+    '''
+        Read EVI file saved by XCounter Hydra PCD detector. Return the images and metadata.
+    '''
+    metadata = {
+        'ImageType': None,
+        'Width': None,
+        'Height': None,
+        'NumberOfImages': None,
+        'OffsetToFirstImage': None,
+        'GapBetweenImages': None,
+        'FrameRate': None,
+        'LowThreshold': None,
+        'HighThreshold': None,
+    }
+
+    mapping = {
+        'Image_Type': 'ImageType',
+        'Width': 'Width',
+        'Height': 'Height',
+        'Nr_of_images': 'NumberOfImages',
+        'Offset_To_First_Image': 'OffsetToFirstImage',
+        # interesting
+        'Gap_between_iamges_in_bytes': 'GapBetweenImages',
+        'Gap_between_images_in_bytes': 'GapBetweenImages',
+        'Frame_Rate_HZ': 'FrameRate',
+        'Low_Thresholds_KV': 'LowThreshold',
+        'High_Thresholds_KV': 'HighThreshold',
+    }
+
+    take = lambda str, idx: str.split(' ')[idx]
+    with open(path, 'r', encoding='utf-8', errors='ignore') as fp:
+        line = fp.readline().strip()
+        while len(line):
+            if line == 'COMMENT':
+                break
+
+            key = take(line, 0)
+            if key in mapping:
+                val = take(line, 1)
+                metadata[mapping[key]] = int(val) if str.isdigit(val) else val
+
+            line = fp.readline().strip()
+
+    nones = list(filter(lambda x: x[1] is None, metadata.items()))
+    cripAssert(len(nones) == 0, f'Failed to find metadata for {list(map(lambda x: x[0], nones))}')
+    cripAssert(metadata['ImageType'] in ['Single', 'Double'], f'Unsupported ImageType: {metadata["ImageType"]}')
+    dtype = {'Single': np.float32, 'Double': np.float64}
+
+    img = imreadRaw(path, metadata['Height'], metadata['Width'], dtype[metadata['ImageType']],
+                    metadata['NumberOfImages'], metadata['OffsetToFirstImage'], metadata['GapBetweenImages'])
+
+    return img, metadata
+
+
+def imreadEVI(path: str):
+    '''
+        Read EVI file saved by XCounter Hydra PCD detector. Return the images only.
+    '''
+    return readEVI(path)[0]
+
+
 def _CTPARAM(loc, type_):
     return {'loc': loc, 'type': type_}
 
 
 # These CT parameters will be retrieved.
 CTPARAMS = {
     # For WC sometimes two values will be fetched. Usually they are the same.
@@ -236,15 +298,15 @@
 }
 
 
 def fetchCTParam(dicom: pydicom.Dataset, key: str):
     '''
         Fetch CT related parameter from DICOM file. Use `readDicom` to get DICOM Dataset.
 
-        @See CTPARAMS in the source code for available keys.
+        @see CTPARAMS in the source code for available keys.
     '''
     metaParam = CTPARAMS[key]
     if metaParam is None:
         return None
     try:
         value = metaParam['type'](dicom[metaParam['loc'][0], metaParam['loc'][1]].value)
     except:
```

## crip/physics.py

```diff
@@ -2,92 +2,100 @@
     Physics module of crip.
 
     https://github.com/z0gSh1u/crip
 '''
 
 __all__ = [
     'Spectrum', 'Atten', 'Material', 'calcMu', 'DiagEnergyLow', 'DiagEnergyHigh', 'DiagEnergyRange', 'DiagEnergyLen',
-    'getClassicDensity', 'forwardProjectWithSpectrum', 'brewPowderSolution', 'calcContrastHU'
+    'forwardProjectWithSpectrum', 'brewPowderSolution', 'calcContrastHU', 'getCommonDensity', 'EnergyConversion'
 ]
 
 import json
 import re
 import numpy as np
-from scipy import interpolate
 from os import path
+import enum
 
 from ._typing import *
 from .utils import cvtEnergyUnit, cvtMuUnit, inArray, cripAssert, getChildFolder, inRange, isNumber, isOfSameShape, isType, readFileText, cvtConcentrationUnit
 from .io import listDirectory
 from .postprocess import muToHU
 
 ## Constants ##
 
 DiagEnergyLow = 0  # keV
 DiagEnergyHigh = 150  # keV
-DiagEnergyRange = range(DiagEnergyLow, DiagEnergyHigh + 1)  # [low, high)
+DiagEnergyRange = range(DiagEnergyLow, DiagEnergyHigh + 1)  # Diagonstic energy range, [low, high)
 DiagEnergyLen = DiagEnergyHigh - DiagEnergyLow + 1
 AttenAliases = {
     'Gold': 'Au',
     'Carbon': 'C',
     'Copper': 'Cu',
     'Iodine': 'I',
     'H2O': 'Water',
     'Gadolinium': 'Gd',
 }
 
 
-def getClassicDensity(materialName: str):
+class EnergyConversion(enum.Enum):
+    EID = 'EID'  # Energy-Integrating Detector
+    PCD = 'PCD'  # Photon-Counting Detector
+
+
+def getCommonDensity(materialName: str):
     '''
-        Get the classic value of density of a specified material (g/cm^3) from built-in dataset.
+        Get the common value of density of a specified material (g/cm^3) from built-in dataset.
     '''
-    _classicRho = readFileText(path.join(getChildFolder('_atten'), './_classicRho.json'))
-    rhoObject = json.loads(_classicRho)
+    rhoObject = json.loads(readFileText(path.join(getChildFolder('_atten'), './_classicRho.json')))
 
-    key = materialName
-    cripAssert(key in rhoObject, f'Record not found for density: {key}')
+    if materialName in AttenAliases:
+        materialName = AttenAliases[materialName]
+    cripAssert(materialName in rhoObject, f'Material not found in density dataset: {materialName}')
 
-    return rhoObject[key]
+    return rhoObject[materialName]
 
 
 class Spectrum:
     '''
         Construct Spectrum object with omega array of every energy.
 
         Get \\omega of certain energy (keV):
         ```py
             omega = spec.omega[E]
         ```
     '''
+
     def __init__(self, omega: np.ndarray, unit='keV'):
-        cripAssert(len(omega) == DiagEnergyLen, 'omega array should have same length as DiagEnergyLen.')
+        cripAssert(
+            len(omega) == DiagEnergyLen,
+            f'omega array should have same length as DiagEnergyLen: got {len(omega)} expect {DiagEnergyLen}.')
         cripAssert(inArray(unit, ['MeV', 'keV', 'eV']), f'Invalid unit: {unit}')
 
         self.unit = unit
-        self.omega = np.array(omega)
+        self.omega = np.array(omega, dtype=np.float32)
         self.sumOmega = np.sum(self.omega)
 
-        self.startEnergy = None
-        self.cutOffEnergy = None
-        for e in DiagEnergyRange:
-            if self.omega[e] > 0:
-                self.startEnergy = e
-            if self.omega[e] <= 0:
-                self.cutOffEnergy = e
-                break
+    def isMonochromatic(self):
+        at = -1
+        for i in DiagEnergyRange:
+            if self.omega[i] > 0:
+                if at != -1:
+                    return False, None
+                at = i
+
+        return True, at
 
     @staticmethod
     def fromText(specText: str, unit='keV'):
         '''
             Parse spectrum text as `Spectrum` class object.
             
             Refer to the document for spectrum text format. @see https://github.com/z0gSh1u/crip            
         '''
         cripAssert(inArray(unit, ['MeV', 'keV', 'eV']), f'Invalid unit: {unit}')
-
         omega = np.zeros(DiagEnergyLen, dtype=DefaultFloatDType)
 
         # split content into list, and ignore all lines starting with non-digit
         content = list(
             filter(lambda y: len(y) > 0 and str.isdigit(y[0]),
                    list(map(lambda x: x.strip(),
                             specText.replace('\r\n', '\n').split('\n')))))
@@ -102,100 +110,106 @@
         specEnergy, specOmega = content.T
         specOmega[specOmega < 0] = 0
 
         # to keV
         specEnergy = cvtEnergyUnit(specEnergy, unit, DefaultEnergyUnit)
 
         startEnergy, cutOffEnergy = int(specEnergy[0]), int(specEnergy[-1])
-        cripAssert(inRange(startEnergy, DiagEnergyRange), '`startEnergy` is out of `DiagEnergyRange`.')
-        cripAssert(inRange(cutOffEnergy, DiagEnergyRange), '`cutOffEnergy` is out of `DiagEnergyRange`.')
+        cripAssert(inRange(startEnergy, DiagEnergyRange),
+                   f'startEnergy is out of DiagEnergyRange: {DiagEnergyRange} keV')
+        cripAssert(inRange(cutOffEnergy, DiagEnergyRange),
+                   f'cutOffEnergy is out of DiagEnergyRange: {DiagEnergyRange} keV')
         cripAssert(cutOffEnergy + 1 - startEnergy == len(specOmega),
                    'The spectrum is not continous by 1 keV from start to cutoff.')
 
         omega[startEnergy:cutOffEnergy + 1] = specOmega[:]
 
         return Spectrum(omega, unit)
 
     @staticmethod
     def fromFile(path: str, unit='keV'):
+        '''
+            Construct a Spectrum object from spectrum file (first column is energy while second is omega).
+        '''
         spec = readFileText(path)
 
         return Spectrum.fromText(spec, unit)
 
     @staticmethod
     def monochromatic(at: int, unit='keV', omega=10**5):
+        '''
+            Construct a monochromatic spectrum.
+        '''
         text = '{} {}\n{} -1'.format(str(at), str(omega), str(at + 1))
 
         return Spectrum.fromText(text, unit)
 
 
 class Atten:
     '''
         Parse atten text as `Atten` class object. Interpolation is performed to fill `DiagEnergyRange`.
+        Refer to the document for atten text format (NIST ASCII). The density is in g/cm^3.
 
-        Refer to the document for atten text format (NIST ASCII or ICRP). @see https://github.com/z0gSh1u/crip
-
-        \\rho: g/cm^3.
-
-        Get \\mu of certain energy (keV):
+        Get \\mu (mm-1) of certain energy (keV):
         ```py
             mu = atten.mu[E]
         ```
     '''
-    def __init__(self, muArray: NDArray, rho: Or[None, float] = None) -> None:
+
+    def __init__(self, muArray: NDArray, density: Or[None, float] = None) -> None:
         cripAssert(len(muArray) == DiagEnergyLen, f'muArray should have length of {DiagEnergyLen} energy bins')
         self.mu = muArray
-        self.rho = rho
+        self.rho = density
         self.attenText = ''
         self.energyUnit = 'keV'
 
     @staticmethod
     def builtInAttenList() -> List:
         '''
-            Get the built-in atten list file content.
+            Get all built-in materials.
         '''
         attenListPath = path.join(getChildFolder('_atten'), './data')
         attenList = list(map(lambda x: x.replace('.txt', ''), listDirectory(attenListPath, style='filename')))
+        attenList.extend(AttenAliases.keys())
 
         return attenList
 
     @staticmethod
     def _builtInAttenText(materialName: str):
         '''
-            Get the built-in atten file content of `materialName`.
-
-            Available data sources: `NIST`, `ICRP`. Call `getBuiltInAttenList` to get the material list.
+            Get the built-in atten file content of `materialName` from NIST data source.
         '''
         if materialName in AttenAliases:
             materialName = AttenAliases[materialName]
 
         attenFilePath = path.join(getChildFolder('_atten'), f'./data/{materialName}.txt')
         cripAssert(path.exists(attenFilePath), f'Atten file for {materialName} does not exist.')
         content = readFileText(attenFilePath)
 
         return content
 
     @staticmethod
-    def fromBuiltIn(materialName: str, rho: Or[float, None] = None):
+    def fromBuiltIn(materialName: str, density: Or[float, None] = None):
         '''
             Get the built-in atten object.
-
-            \\rho: g/cm^3.
+            Call `builtInAttenList` to get available materials.
+            The density is in g/cm^3.
         '''
         if materialName in AttenAliases:
             materialName = AttenAliases[materialName]
 
-        if rho is None:
-            rho = getClassicDensity(materialName)
+        if density is None:
+            density = getCommonDensity(materialName)
 
-        return Atten.fromText(Atten._builtInAttenText(materialName), rho, BuiltInAttenEnergyUnit)
+        return Atten.fromText(Atten._builtInAttenText(materialName), density, BuiltInAttenEnergyUnit)
 
     @staticmethod
-    def fromText(attenText: str, rho: float, energyUnit='MeV'):
-        cripAssert(rho > 0, '`rho` should > 0.')
+    def fromText(attenText: str, density: float, energyUnit='MeV'):
+        cripAssert(density > 0, '`density` should > 0.')
+        rho = density
 
         # split attenText into list, and ignore all lines starting with non-digit
         content = list(
             filter(lambda y: len(y) > 0 and str.isdigit(y[0]),
                    list(map(lambda x: x.strip(),
                             attenText.replace('\r\n', '\n').split('\n')))))
 
@@ -223,53 +237,46 @@
 
     @staticmethod
     def fromMuArray(muArray: NDArray, rho: Or[float, None] = None):
         return Atten(muArray, rho)
 
     @staticmethod
     def fromFile(path: str, rho: float, energyUnit='MeV'):
+        '''
+            Construct a new material from file where first column is energy while second
+            is \\mu / \\rho.
+        '''
         atten = readFileText(path)
 
         return Atten.fromText(atten, rho, energyUnit)
 
 
 Material = Atten
 WaterAtten = Atten.fromBuiltIn('Water')
 
 
-def calcMu(atten: Atten, spec: Spectrum, energyConversion: Or[str, float, int, Callable]) -> float:
+def calcMu(atten: Atten, spec: Spectrum, energyConversion: str) -> float:
     '''
-        Calculate the \mu value (mm-1) of certain atten under a specific spectrum.
-
-        `energyConversion` determines the energy conversion efficiency of the detector.
-            - "PCD" (Photon Counting), "EID" (Energy Integrating)
-            - a constant value
-            - a callback function that takes energy in keV and returns the factor
+        Calculate the LAC \mu value (mm-1) of certain atten under a specific spectrum.
+        energyConversion determines the energy conversion efficiency of the detector,
+        can be "PCD" (Photon Counting), "EID" (Energy Integrating)
     '''
-    mus = atten.mu
-    eff = None
+    cripAssert(inArray(energyConversion, ['PCD', 'EID']), f'Invalid energyConversion: {energyConversion}')
 
-    if isType(energyConversion, str):
-        cripAssert(inArray(energyConversion, ['PCD', 'EID']), f'Invalid `energyConversion`: {energyConversion}')
-        eff = {'PCD': 1, 'EID': np.array(DiagEnergyRange)}[energyConversion]
-    elif isNumber(energyConversion):
-        eff = energyConversion
-    elif isType(energyConversion, Callable):
-        eff = np.array(list(map(energyConversion, list(DiagEnergyRange)))).squeeze()
-    else:
-        cripAssert(False, 'Invalid `energyConversion`.')
+    mus = atten.mu
+    eff = {'PCD': 1, 'EID': np.array(DiagEnergyRange)}[energyConversion]
 
     return np.sum(spec.omega * eff * mus) / np.sum(spec.omega * eff)
 
 
 def calcAttenedSpec(spec: Spectrum, attens: Or[Atten, List[Atten]], Ls: Or[float, List[float]]) -> Spectrum:
     '''
         Calculate the attenuated spectrum using polychromatic Beer-Lambert law. Supports multiple materials.
 
-        I.e., `\\Omega(E) \\exp (- \\mu(E) L) \\through all E`. L in mm.
+        I.e., `\\Omega(E) \\exp (- \\mu(E) L) through all E`. L in mm.
     '''
     if isType(attens, Atten):
         attens = [attens]
     if isType(Ls, float):
         Ls = [Ls]
     cripAssert(len(attens) == len(Ls), 'atten should have same length as L.')
 
@@ -289,69 +296,78 @@
         Calculate post-log value after attenuation of `L` length `atten`. L in mm.
     '''
     attenSpec = calcAttenedSpec(spec, atten, L)
 
     return -np.log(attenSpec.sumOmega / spec.sumOmega)
 
 
-def forwardProjectWithSpectrum(lengths: List[TwoD],
-                               materials: List[Atten],
-                               spec: Spectrum,
-                               energyConversion: str,
-                               fastSkip: bool = False,
-                               flat: float = None):
+def forwardProjectWithSpectrum(lengths: List[TwoD], materials: List[Atten], spec: Spectrum, energyConversion: str):
     '''
         Perform forward projection using `spec`. `lengths` is a list of corresponding length [mm] images 
-        (projection or sinogram) of `materials`. Set `lengths` and `materials` to empty lists to compute the flat field.
+        (projection or sinogram) of `materials`. 
         This function would simulate attenuation and Beam Hardening but no scatter.
+        
+        Set `lengths` and `materials` to empty lists to compute the flat field.
+
+        It's highly recommended to use a monochronmatic spectrum to accelerate if you simulate a lot.
     '''
     cripAssert(len(lengths) == len(materials), 'Lengths and materials should correspond.')
     cripAssert(all([isOfSameShape(lengths[0], x) for x in lengths]), 'Lengths map should have same shape.')
     cripAssert(energyConversion in ['PCD', 'EID'], 'Invalid energyConversion.')
 
     efficiency = 1 if energyConversion == 'PCD' else np.array(DiagEnergyRange)
 
-    if (len(lengths) == 0) or (fastSkip and (all([np.sum(x) == 0 for x in lengths]))):
+    if len(lengths) == 0:
+        # compute the flat field
         ones = np.ones_like(lengths[0], dtype=DefaultFloatDType) if len(lengths) > 0 else 1
-        if flat is not None:
-            return flat * ones
-        else:
-            effectiveOmega = spec.omega * efficiency
-            return np.sum(effectiveOmega) * ones
+        effectiveOmega = spec.omega * efficiency
+
+        return np.sum(effectiveOmega) * ones
 
     resultShape = lengths[0].shape
 
-    # a[h, w] = [vector of attenuation in that energy bin]
-    attenuations = np.zeros((*resultShape, DiagEnergyLen), dtype=DefaultFloatDType)
-    for length, material in zip(lengths, materials):
-        attenuations += np.outer(length, material.mu).reshape((*resultShape, DiagEnergyLen))
+    # speed up when it's monochromatic
+    isMono, monoAt = spec.isMonochromatic()
+    if isMono:
+        attenuations = 0.0
+        for length, material in zip(lengths, materials):
+            attenuations += length * material.mu[monoAt]
 
-    attened = spec.omega * np.exp(-attenuations) * efficiency  # the attenuated image
+        attened = spec.omega[monoAt] * np.exp(-attenuations) * efficiency  # the attenuated image
+    else:
+        # a[h, w] = [vector of attenuation in that energy bin]
+        attenuations = np.zeros((*resultShape, DiagEnergyLen), dtype=DefaultFloatDType)
+        for length, material in zip(lengths, materials):
+            attenuations += np.outer(length, material.mu).reshape((*resultShape, DiagEnergyLen))
+
+        attened = spec.omega * np.exp(-attenuations) * efficiency  # the attenuated image
 
     return np.sum(attened, axis=-1)
 
 
 def brewPowderSolution(solute: Atten,
                        solvent: Atten,
                        concentration: float,
                        concentrationUnit='mg/mL',
                        rhoSolution: Or[float, None] = None) -> Atten:
     '''
         Generate the Atten of powder solution with certain concentration (mg/mL by default).
     '''
+    cripAssert(inArray(concentrationUnit, ['mg/mL', 'g/mL']), f'Invalid concentration unit: {concentrationUnit}')
+
     concentration = cvtConcentrationUnit(concentration, concentrationUnit, 'g/mL')
     mu = solvent.mu + (solute.mu / solute.rho) * concentration
     atten = Atten.fromMuArray(mu, rhoSolution)
 
     return atten
 
 
 def calcContrastHU(contrast: Atten, spec: Spectrum, energyConversion: str, base: Atten = WaterAtten):
     '''
-        Calculate the contrast difference in HU.
+        Calculate HU difference resulted by contrast.
     '''
     cripAssert(energyConversion in ['EID', 'PCD'], 'Invalid energyConversion.')
 
     _calcMu = lambda atten: calcMu(atten, spec, energyConversion)
 
     muWater = _calcMu(WaterAtten)
     if base is not WaterAtten:
```

## crip/preprocess.py

```diff
@@ -179,15 +179,15 @@
     if isType(coeffs, Tuple):
         if bias is False:
             coeffs = np.poly1d([*coeffs, 0])
 
     return coeffs(postlog)
 
 
-def fan2para(sgm, gammas, betas, d, oThetas, oLines):
+def fan2para(sgm: TwoD, gammas, betas, d, oThetas, oLines):
     '''
         Re-order Fan-Beam sinogram to Parallel-Beam's.
         gammas: the fan angles from min to max
         betas: the rotation angles from min to max
         d: Source-Isocenter-Distance
         oThetas: output rotation angle [min, delta, max]
         oLines: output detector element physical locs [min, delta, max]
```

## Comparing `crip-1.6.3.dist-info/LICENSE` & `crip-1.7.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `crip-1.6.3.dist-info/METADATA` & `crip-1.7.dist-info/METADATA`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: crip
-Version: 1.6.3
+Version: 1.7
 Summary: An all-in-one tool for Cone-Beam CT Data IO, Pre/Post-process, and Physics, Dual Energy, Low Dose researches and everything only except Reconstruction.
 Home-page: https://github.com/z0gSh1u/crip
 Author: z0gSh1u, CandleHouse
 Author-email: zx.cs@qq.com
 License: MIT License
 License-File: LICENSE
 Requires-Dist: numpy
```

## Comparing `crip-1.6.3.dist-info/RECORD` & `crip-1.7.dist-info/RECORD`

 * *Files 2% similar despite different names*

```diff
@@ -1,18 +1,19 @@
-crip/__init__.py,sha256=B-awW9Ni0TKwyoV70QStnJuefmwln_tn4Fi4_ppwxcE,666
+crip/__init__.py,sha256=vw4TFMFGBU6ejsaZLiUkNTJsZm3hS_xY8G1d8DiC_iA,662
 crip/_typing.py,sha256=df0QD0r2RAYxOC_LiNNVAa8FTzyu18ktsgyBQZ0MN_Y,766
-crip/de.py,sha256=1fTxw0hFdB6Uew9qopnzvvvYTgZYfRbJ4a-9cW_eEMQ,4206
-crip/io.py,sha256=9WCp6A4F6HT3QXUITxzj10NFnEjbMXYi_hczPPOQZ50,8354
+crip/de.py,sha256=4jL_QPmVQjEElJ5khixlIUkQ7wQ-eubGmP0Tii78KZA,5698
+crip/io.py,sha256=kCxAik2hotCcFOG2nXWB3XIfqh-PW3fy08obuJHj6VQ,10520
 crip/lowdose.py,sha256=-rxNVo1ohcmiOHd-6hKvwADKoDbS5MohPBjkCapuX84,2614
 crip/mangoct.py,sha256=KUucuwM9LCX9c3bbI3CxEWN1G-pINTmIrZl1j1okKr4,11032
 crip/metric.py,sha256=eI0zdTg3rc_XS0IYd-8APWLaJHlcY6yI2zJ3wdM5RQU,1431
 crip/paplot.py,sha256=p356eMqoAZtANfIFOezKq_4tmfef0AJM_o8w1SBoiDA,2702
-crip/physics.py,sha256=G7HfFbkfkeD3b-gWCfZJQqVGoziUIMltM_JR74prCjc,13593
+crip/physics.py,sha256=0RZ7ndrhjzSleQQ0TviwBhKaE39fweHw-F5AKHoXB6A,14180
+crip/plot.py,sha256=p356eMqoAZtANfIFOezKq_4tmfef0AJM_o8w1SBoiDA,2702
 crip/postprocess.py,sha256=hSyBE9BUfV_PjlFLkaeM0BHrowrLX7dZDf3ilFOZ4L8,3724
-crip/preprocess.py,sha256=lOTR8TNoZyEDu5C1oVj2Cf9x5W4es3ix1nQT_oRq_CE,8211
+crip/preprocess.py,sha256=y-7XPE1ly10-32LW24lB29r6bJ2zQNyVSMLV_40O2aQ,8217
 crip/shared.py,sha256=uMmBtyZkCmPudsYZlFqupsB9n6QVXpVAm620luFvCC4,6678
 crip/utils.py,sha256=ZRbfg9UaXQcgaAYi7veOqg7QD9byDbJ67TV8he8KnLk,5528
 crip/_atten/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 crip/_atten/_attenList.json,sha256=M1Up8UUp0KGdCX3_NWVweCTB3ZBDiR51r_5xNdetMeE,1304
 crip/_atten/_classicRho.json,sha256=kRwqXC7empNwsSMJJPfx8QRtkHS71M2TG_Pd1Oe5Qog,548
 crip/_atten/_updateList.py,sha256=3nYGpN3-yRo1oMMjHA15nzWNR8xXwzazEMh5cuUGcuI,627
 crip/_atten/compound/CaF2.txt,sha256=Z-AdXrL2xAuJvYNYI47PvB_-F9qtznHDNJuZp0e2Aq8,592
@@ -100,12 +101,12 @@
 crip/_atten/simple/Ni.txt,sha256=5S8dxRCTgQsTxD3RkPjb_YpRJGc-wduH_x2JJqz2tPc,922
 crip/_atten/simple/O.txt,sha256=-r6uX2Vf-lYjprVMJWMGhtSxh9TLUvj12sdvWZuCt9U,823
 crip/_atten/simple/P.txt,sha256=HtQ4uYZwexG7thBcLvDk2BuE60G3nt2CWrHOGe7qE_8,691
 crip/_atten/simple/S.txt,sha256=aFgIQ8PMzmhJsa4fwQMtj9x2gDSIRKsYT7b91OgfueY,691
 crip/_atten/simple/Si.txt,sha256=co_6iJLCXZdprevjyFxzWTciETYXNIWbEsoAyxTNkU8,823
 crip/_atten/simple/Sn.txt,sha256=mA3ifgpRmP9OA4A9LdTwgItrUJuLq8xR8qV7G0RpXz4,526
 crip/_atten/simple/Ti_ICRP.txt,sha256=Fu_F3FqJ7Ym253puOuyT-4Isims_g8U7xmJWjxE-GDM,652928
-crip-1.6.3.dist-info/LICENSE,sha256=_rwEaI2Dwbuo9A5DAFjEM8es8P3CyRGJSryEvjZxe9Q,1052
-crip-1.6.3.dist-info/METADATA,sha256=CjNwL6w5FEZ2NgVcX85tDhQ3WCz_i3BI91pQnBt2w5g,526
-crip-1.6.3.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-crip-1.6.3.dist-info/top_level.txt,sha256=hoeB5IVBFjWadPtRY1-Zg9csrS7n058Tb3nGFY2pfu8,5
-crip-1.6.3.dist-info/RECORD,,
+crip-1.7.dist-info/LICENSE,sha256=_rwEaI2Dwbuo9A5DAFjEM8es8P3CyRGJSryEvjZxe9Q,1052
+crip-1.7.dist-info/METADATA,sha256=A_wc9DV6i7EXeybsHA3A-sjRSf02SeBtvSGfUKGRkvc,524
+crip-1.7.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+crip-1.7.dist-info/top_level.txt,sha256=hoeB5IVBFjWadPtRY1-Zg9csrS7n058Tb3nGFY2pfu8,5
+crip-1.7.dist-info/RECORD,,
```

